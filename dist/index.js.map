{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/assign.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar resolveGetter = require( '@stdlib/array-base-resolve-getter' );\nvar ind = require( '@stdlib/ndarray-base-ind' ).factory;\n\n\n// MAIN //\n\n/**\n* Takes elements from an array.\n*\n* @param {Collection} x - input array\n* @param {IntegerArray} indices - list of indices\n* @param {string} mode - index mode\n* @returns {Array} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var indices = [ 3, 1, 2, 0 ];\n*\n* var y = take( x, indices, 'throw' );\n* // returns [ 4, 2, 3, 1 ]\n*/\nfunction take( x, indices, mode ) {\n\tvar getIndex;\n\tvar xget;\n\tvar iget;\n\tvar out;\n\tvar max;\n\tvar i;\n\tvar j;\n\n\t// Resolve an accessor for retrieving array elements:\n\txget = resolveGetter( x );\n\tiget = resolveGetter( indices );\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = x.length - 1;\n\n\t// Extract each desired element from the provided array...\n\tout = [];\n\tfor ( i = 0; i < indices.length; i++ ) {\n\t\tj = getIndex( iget( indices, i ), max );\n\t\tout.push( xget( x, j ) ); // use `Array#push` to ensure \"fast\" elements\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = take;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isComplexDataType = require( '@stdlib/array-base-assert-is-complex-floating-point-data-type' );\nvar isBooleanDataType = require( '@stdlib/array-base-assert-is-boolean-data-type' );\nvar arraylike2object = require( '@stdlib/array-base-arraylike2object' );\nvar reinterpret = require( '@stdlib/strided-base-reinterpret-complex' );\nvar reinterpretBoolean = require( '@stdlib/strided-base-reinterpret-boolean' );\nvar ind = require( '@stdlib/ndarray-base-ind' ).factory;\n\n\n// FUNCTIONS //\n\n/**\n* Takes elements from an indexed array and assigns the values to elements in an indexed output array.\n*\n* @private\n* @param {Collection} x - input array\n* @param {IntegerArray} indices - list of indices\n* @param {string} mode - index mode\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var indices = [ 3, 1, 2, 0 ];\n*\n* var out = [ 0, 0, 0, 0 ];\n*\n* var arr = indexed( x, indices, 'throw', out, 1, 0 );\n* // returns [ 4, 2, 3, 1 ]\n*/\nfunction indexed( x, indices, mode, out, stride, offset ) {\n\tvar getIndex;\n\tvar max;\n\tvar io;\n\tvar i;\n\tvar j;\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = x.length - 1;\n\n\t// Extract each desired element from the provided array...\n\tio = offset;\n\tfor ( i = 0; i < indices.length; i++ ) {\n\t\tj = getIndex( indices[ i ], max );\n\t\tout[ io ] = x[ j ];\n\t\tio += stride;\n\t}\n\treturn out;\n}\n\n/**\n* Takes elements from an accessor array and assigns the values to elements in an accessor output array.\n*\n* @private\n* @param {Object} x - input array object\n* @param {Object} indices - index array object\n* @param {string} mode - index mode\n* @param {Object} out - output array object\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array\n*\n* @example\n* var toAccessorArray = require( '@stdlib/array-base-to-accessor-array' );\n* var arraylike2object = require( '@stdlib/array-base-arraylike2object' );\n*\n* var x = toAccessorArray( [ 1, 2, 3, 4 ] );\n* var indices = toAccessorArray( [ 3, 1, 2, 0 ] );\n*\n* var out = toAccessorArray( [ 0, 0, 0, 0 ] );\n* var arr = accessors( arraylike2object( x ), arraylike2object( indices ), 'throw', arraylike2object( out ), 1, 0 );\n*\n* var v = arr.get( 0 );\n* // returns 4\n*/\nfunction accessors( x, indices, mode, out, stride, offset ) {\n\tvar getIndex;\n\tvar xdata;\n\tvar idata;\n\tvar odata;\n\tvar xget;\n\tvar iget;\n\tvar oset;\n\tvar max;\n\tvar io;\n\tvar i;\n\tvar j;\n\n\txdata = x.data;\n\tidata = indices.data;\n\todata = out.data;\n\n\txget = x.accessors[ 0 ];\n\tiget = indices.accessors[ 0 ];\n\toset = out.accessors[ 1 ];\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = xdata.length - 1;\n\n\t// Extract each desired element from the provided array...\n\tio = offset;\n\tfor ( i = 0; i < idata.length; i++ ) {\n\t\tj = getIndex( iget( idata, i ), max );\n\t\toset( odata, io, xget( xdata, j ) );\n\t\tio += stride;\n\t}\n\treturn odata;\n}\n\n/**\n* Takes elements from a complex array and assigns the values to elements in a complex output array.\n*\n* @private\n* @param {Collection} x - real-valued floating-point input array view\n* @param {Object} indices - index array object\n* @param {string} mode - index mode\n* @param {Collection} out - real-valued floating-point output array view\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array view\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var arraylike2object = require( '@stdlib/array-base-arraylike2object' );\n*\n* var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var indices = [ 0, 0, 1, 1 ];\n*\n* var out = new Float64Array( 8 );\n*\n* var arr = complex( x, arraylike2object( indices ), 'throw', out, 1, 0 );\n* // returns <Float64Array>[ 1.0, 2.0, 1.0, 2.0, 3.0, 4.0, 3.0, 4.0 ]\n*/\nfunction complex( x, indices, mode, out, stride, offset ) {\n\tvar getIndex;\n\tvar idata;\n\tvar iget;\n\tvar max;\n\tvar io;\n\tvar so;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tidata = indices.data;\n\tiget = indices.accessors[ 0 ];\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = ( x.length/2 ) - 1; // resolve the length of the original complex array\n\n\t// Extract each desired element from the provided array...\n\tso = stride * 2; // note: multiply by 2, as real-valued array consists of interleaved real and imaginary components\n\tio = offset * 2;\n\tfor ( i = 0; i < idata.length; i++ ) {\n\t\tj = getIndex( iget( idata, i ), max );\n\t\tk = j * 2;\n\t\tout[ io ] = x[ k ];\n\t\tout[ io+1 ] = x[ k+1 ];\n\t\tio += so;\n\t}\n\treturn out;\n}\n\n/**\n* Takes elements from a boolean array and assigns the values to elements in a boolean output array.\n*\n* @private\n* @param {Collection} x - boolean value input array view\n* @param {Object} indices - index array object\n* @param {string} mode - index mode\n* @param {Collection} out - boolean value output array view\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array view\n*\n* @example\n* var Uint8Array = require( '@stdlib/array-uint8' );\n* var arraylike2object = require( '@stdlib/array-base-arraylike2object' );\n*\n* var x = new Uint8Array( [ 1, 0, 0, 1 ] );\n* var indices = [ 0, 0, 1, 1 ];\n*\n* var out = new Uint8Array( 4 );\n*\n* var arr = boolean( x, arraylike2object( indices ), 'throw', out, 1, 0 );\n* // returns <Uint8Array>[ 1, 1, 0, 0 ]\n*/\nfunction boolean( x, indices, mode, out, stride, offset ) {\n\tvar getIndex;\n\tvar idata;\n\tvar iget;\n\tvar max;\n\tvar io;\n\tvar i;\n\tvar j;\n\n\tidata = indices.data;\n\tiget = indices.accessors[ 0 ];\n\n\t// Resolve a function for returning an index according to the specified index mode:\n\tgetIndex = ind( mode );\n\n\t// Resolve the maximum index:\n\tmax = x.length - 1;\n\n\t// Extract each desired element from the provided array...\n\tio = offset;\n\tfor ( i = 0; i < idata.length; i++ ) {\n\t\tj = getIndex( iget( idata, i ), max );\n\t\tout[ io ] = x[ j ];\n\t\tio += stride;\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Takes elements from an array and assigns the values to elements in a provided output array.\n*\n* @param {Collection} x - input array\n* @param {IntegerArray} indices - list of indices\n* @param {string} mode - index mode\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {Collection} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n* var indices = [ 3, 1, 2, 0 ];\n*\n* var out = [ 0, 0, 0, 0 ];\n* var arr = assign( x, indices, 'throw', out, 1, 0 );\n* // returns [ 4, 2, 3, 1 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\nfunction assign( x, indices, mode, out, stride, offset ) {\n\tvar xo;\n\tvar io;\n\tvar oo;\n\n\txo = arraylike2object( x );\n\tio = arraylike2object( indices );\n\too = arraylike2object( out );\n\tif (\n\t\txo.accessorProtocol ||\n\t\tio.accessorProtocol ||\n\t\too.accessorProtocol\n\t) {\n\t\t// Note: we only explicitly support a limited set of dtype-to-dtype pairs, as this function should not be concerned with casting rules, etc. That is left to userland...\n\t\tif (\n\t\t\tisComplexDataType( xo.dtype ) &&\n\t\t\tisComplexDataType( oo.dtype )\n\t\t) {\n\t\t\tcomplex( reinterpret( x, 0 ), io, mode, reinterpret( out, 0 ), stride, offset ); // eslint-disable-line max-len\n\t\t\treturn out;\n\t\t}\n\t\tif (\n\t\t\tisBooleanDataType( xo.dtype ) &&\n\t\t\tisBooleanDataType( oo.dtype )\n\t\t) {\n\t\t\tboolean( reinterpretBoolean( x, 0 ), io, mode, reinterpretBoolean( out, 0 ), stride, offset ); // eslint-disable-line max-len\n\t\t\treturn out;\n\t\t}\n\t\taccessors( xo, io, mode, oo, stride, offset );\n\t\treturn out;\n\t}\n\tindexed( x, indices, mode, out, stride, offset );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = assign;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Take elements from an array.\n*\n* @module @stdlib/array-base-take\n*\n* @example\n* var take = require( '@stdlib/array-base-take' );\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* var indices = [ 0, 0, 1, 1, 3, 3 ];\n* var y = take( x, indices, 'throw' );\n* // returns [ 1, 1, 2, 2, 4, 4 ]\n*\n* @example\n* var take = require( '@stdlib/array-base-take' );\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0, 0, 0, 0 ];\n* var indices = [ 0, 0, 1, 1, 3, 3 ];\n*\n* var arr = take.assign( x, indices, 'throw', out, 1, 0 );\n* // returns [ 1, 1, 2, 2, 4, 4 ]\n*\n* var bool = ( arr === out );\n* // returns true\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "resolveGetter", "ind", "take", "x", "indices", "mode", "getIndex", "xget", "iget", "out", "max", "i", "j", "require_assign", "__commonJSMin", "exports", "module", "isComplexDataType", "isBooleanDataType", "arraylike2object", "reinterpret", "reinterpretBoolean", "ind", "indexed", "x", "indices", "mode", "out", "stride", "offset", "getIndex", "max", "io", "i", "j", "accessors", "xdata", "idata", "odata", "xget", "iget", "oset", "complex", "so", "k", "boolean", "assign", "xo", "oo", "setReadOnly", "main", "assign"]
}
